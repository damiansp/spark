Element-wise Transformations
   * map()
      map(x => x * x); { 1, 2, 3, 4 } => { 1, 3, 9, 16 }
   * filter()
      filter(x => x % 2 == 0); { 1, 2, 3, 4 } => { 2, 4 }
   * flatMap()
      maps elements to multiple outputs
      flatMap(lines => lines.split(" ")

      { "this string", "that string" "string time" }
      tokenize("a b") => "a" "b"
      map(tokenize) => { ["this", "string"], ["that", "string"], ["string", "time"] }
      flatMap(tokenize) => { "this", "string", "that", "string", "string", "time" }
   * sample(withReplacement, fraction, [seed])
      rdd.sample(false, 0.2)

Pseudo-set Operations
   RDD1 = { coffee, panda, monkey, tea }
   RDD2 = { coffee, monkey, kitty, cake }
   * distinct()
   * union()
      RDD1.union(RDD2)
         { coffee panda, monkey, tea, kitty, cake }
   * intersection()
      RDD1.intersection(RDD2)
         { coffee, monkey }
   * subtraction()
      RDD1.subtract(RDD2)
         { panda, tea }
   * cartesian()
      RDD1.cartesian(RDD2)
         { (coffee, coffee), (coffee, monkey) ... (cofee, cake), (panda, coffee) ... (tea, cake) }
         
Actions
   * reduce()
      rdd.reduce((x, y) => x + y)
   * collect()
      gathers all partitions to a single machine
      rdd.collect()
   * count()
   * countByValue()
   * take(num)
      rdd.take(7)
   * top(num)
      rdd.top(5)
   * takeSample(withReplacement, num, [seed])
      takeSample(true, 12, 1221)
   * reduce(func)
      rdd.reduce((x, y) => x + y) // sum
   * fold(identity)(func)
      rdd.fold(1)((x, y) => x * y) // product
   * aggregate(identity)(seqOp, combOp)
      rdd.aggregate((0, 0))((x, y) => (x._1 + y, x._2 + 1),
                            (x, y) => (x._1 + y._1, x._2 + y._2)) // running sum and count
   * foreach(func)
